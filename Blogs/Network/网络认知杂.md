参考连接：
https://blog.csdn.net/liutong123987/article/details/79401462
https://blog.csdn.net/yl02520/article/details/7298309
https://www.cnblogs.com/zyy1688/p/10002089.html
https://www.cnblogs.com/jingmoxukong/p/7755643.html
https://www.cnblogs.com/fuqiang88/p/5956363.html

TCP
手机能够使用联网功能是因为手机底层实现了TCP/IP协议，可以使手机终端通过无线网络建立TCP连接
TCP协议可以对上层网络提供接口，使上层网络数据的传输建立在“无差别”的网络之上
建立TCP连接的三次握手：请求，确认，建立连接
1. 客户端发送syn（syn=j）包到服务器，进入SYN_SEN状态，等待服务器确认
    (C发送一个请求连接的位码SYN和一个随机产生的序列号给Seq，然后S收到了这些数据，这个是第一次连接)
2. 服务器收到syn包，必须确认客户都的SYN（ack=j+1），同时自己发送一个SYN+ACK包，服务器进入SYN_RECV状态
    (S收到了这个请求连接的位码，啊呀，有人向我发出请求了么，那我要不要接受他的请求，得实现确认一下，于是，发送了一个确认码 ACN（seq+1），和SYN，Seq给C，然后C收到了，这个是第二次连接)
3. 客户端收到服务器的SYN+ACK包，客户端确认好了SYN包(原先自己发的j，服务器过来应该是j+1)，向服务器发送确认包ACK（ack=k+1），此包发送完毕，客户端和服务端进入ESTABLISH状态，完成三次握手
    (C收到了确认的码和之前发送的SYN一比较，偶哟，对上了么，于是他又发送了一个ACN（SEQ+1）给S，S收到以后就确定建立连接，至此，TCP连接建立完成，这是第三次连接)
注意点：
握手过程中传送的包里不包含任何数据
三次握手完毕后，客户端和服务器才正式开始传送数据
理想状态下，TCP连接一旦建立，在通信双方任何一方主动关闭之前，TCP连接将被一直保持下去
断开连接时，服务器和客户端均可以主动发起断开TCP连接的请求
断开过程需要经过“四次握手”

HTTP
HTTP协议，即超文本传输协议，是Web联网的基础，也是手机联网的常用协议之一。HTTP协议是建立在TCP协议之上的一种应用
HTTP连接的特点：
客户端发送的每次请求都需要服务器回送响应
在请求结束后，会主动释放连接
从建立连接到关闭连接的过程称为“一次连接”
由于HTTP在每次请求结束后都会主动释放连接，所以HTTP连接是一种“短连接”
要保持客户端程序的在线状态，需要不断地向服务器发起请求，即使不需要获得任何数据，客户端也要保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，若双方彼此长时间没有收到对方的回复，则可以认为对方下线或者网络断开
HTTP协议版本的不同：
1. 在HTTP1.0的时候，客户端每次请求都要建立一次单独的连接，处理完本次请求后，自动释放连接
2. 在HTTP1.1的时候，可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下个请求
HTTP请求过程：
1. 发送一个http请求给S，这个请求包括请求头和请求内容：
request header：
请求的方法是POST/GET
请求的URL
http协议版本
编码方式
是否有cookie
是否缓存等。
post和get请求方式的区别是，get把请求内容放在URL后面，但是URL长度有限制。而post是以表单的形势，适合要输入密码之类的，因为不在URL中显示，所以比较安全。
request body：即请求的内容.
2. S收到了http请求，然后根据请求头，返回http响应。
response header:
cookies或者sessions
状态吗
内容大小等
response body：即响应的内容，包括，JS什么的。
3. C收到了以后，就由浏览器完成一系列的渲染，包括执行JS脚本等。

Sokcet
Socket是一组编程接口（API），介于传输层和应用层之间，向应用层提供统一的编程接口
应用层不必了解TCP/IP协议细节，直接通过对Socket接口函数的调用完成数据在IP网络的传输

基于传输层差异，存在4种类型的Socket：
1. 基于TCP的Socket：提供给应用层可靠的流式数据服务，优点：基于数据传输的可靠性
    使用TCP的Socket应用程序或协议：BGP、HTTP、FTP、TELNET等
2. 基于UDP的Socket：适用于数据传输可靠性要求不高的场合
    使用UDP的Socket应用程序或协议：RIP、SNMP、L2TP等
3. 基于RawIp的Socket：非连接，不可靠的数据传输，特点：能使应用程序直接访问网络层
    使用RawIpSocket应用程序或协议：ping、tracert、ospf等
4. 基于链路层的Socket：为IS-IS协议提供的Socket接口，使IS-IS协议可通过Socket直接访问链路层；非连接，不可靠通信服务

Socket原理：
Socket(套接字)是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元，是网络通信过程中端点的抽象表示
包含进行网络通信必须的五种信息：
1. 连接使用的协议
2. 本地主机的IP地址
3. 本地进程的协议端口
4. 远地主机的IP地址
5. 远地进程的协议端口
应用程序通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。
多个TCP连接或者多个应用程序进程可能需要同一个TCP协议端口传输数据，为了区别不同应用程序进程和连接，许多计算机操作系统为应用进程与TCP/IP协议交互提供了套接字(Socket)接口
应用层可以和传输层通过Socket接口，区分来自不同应用程序或网络连接的通信，实现数据传输的并发服务

Socket连接
建立Socket连接至少需要一对套接字(Socket)，其中一个运行在客户端 - ClientSocket，一个运行在服务器端 - ServerSocket
套接字之间的连接分为三个步骤：服务器监听，客户端请求，连接确认
服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求
客户端请求：客户端套接字提出连接请求，要连接的目标是服务器端的套接字，为此客户端的套接字必须首先描述他要连接的服务器端套接字，指出服务器端套接字的地址和端口号
连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字请求，建立一个新的线程，把服务器端套接字描述发给客户端，客户端一旦确认描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求

WebSocket
WebSocket是一个完整的应用层协议，是基于TCP协议来传输数据的（在单个TCP连接上进行全双工通讯的协议），包含一套标准的API，可以把WebSocket这种高级协议理解为对TCP的封装
而Socket并不是一个协议，只是一个抽象层，支持传输层的协议对应用层开放的编程接口(API)而已

WebSocket 只需要建立一次连接，就可以一直保持连接状态；相比于轮询方式不停建立连接显然效率大大提升
对于 WebSocket 来说，它必须依赖 HTTP 协议进行一次握手 ，握手成功后，数据就直接从 TCP 通道传输，与 HTTP 无关了

为什么要WebSocket，这要从HTTP，以及(短)轮询，长轮询发展史来讲：
1. HTTP一定意义上是一种“短连接”，采用“请求-响应”的模式，每次数据传输都要建立连接，且服务器端不能主动推送数据给客户端（HTTP协议是无状态，无连接，单向的应用层协议）
设想：针对股票，火车票，客户端实时想知道股票行情和火车票余票怎么办？
2. (短)轮询：那么只能客户端周期性地定期向服务端发送请求，如此反复 -> 成为(短)轮询
    弊端：这样虽然可以满足需求，但是当服务端数据并未更新时，客户端还是会发送请求过来，由于HTTP的Headr的太大了，就浪费了网络带宽和CPU利用率。但是如果轮询周期大一点，这样就获取不了实时数据了
3. 长轮询：针对(短)轮询的弊端，长轮询应运而生。当客户端发送请求给服务端，服务端有数据的话就直接返回，服务端没有数据的话就会hold住这个请求，等服务端有新的数据了，再响应这个请求。当然hold时间太长会超时，这样的话客户端会立即再发送一个新的请求给服务器，如此反复
    弊端：例如假设服务器端的数据更新速率较快，服务器在传送一个数据包给Browser后必须等待Browser的下一个Get请求到来，才能传递第二个更新的数据包给Browser，那么这样的话，Browser显示实时数据最快的时间为2×RTT（往返时间），另外在网络拥塞的情况下，这个应该是不能让用户接受的
4. 如果客户端有一种新的网络协议，能支持客户端和服务端双向通信，且协议头部又不那么庞大就好了，正好WebSocket应运而生
总结：WebSocket 是为了满足基于 Web 的日益增长的实时通信需求而产生的。在传统的 Web 中，要实现实时通信，通用的方式是采用 HTTP 协议不断发送请求（轮询和长轮询）。但这种方式即浪费带宽（HTTP HEAD 是比较大的），又消耗服务器 CPU 占用（没有信息也要接受请求）

Socket 与 TCP
创建Socket连接，可指定使用的传输层协议，Socket可以支持不同的传输层协议，比如TCP、UDP等
使用TCP协议进行Socket连接时，该Socket连接就是一个TCP连接

Socket 与 HTTP
Socket连接就是TCP连接（通常情况下），因此Socket连接一旦建立，就可以双方互相发送数据，直到连接断开
HTTP连接使用的是“请求---响应”的方式，不仅需要在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器才能回复数据
针对Socket连接，在实际网络应用中，客户端到服务端之间往往要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙会关闭处于未活跃状态的连接而导致Socket连接断连，因此需要轮询告诉网络该连接处于活跃状态

TCP 与 HTTP
TCP是传输层通讯协议，定义的是数据传输和连接方式的规范
HTTP是应用层协议，定义的是传输数据的内容的规范
HTTP协议中的数据是利用TCP协议传输的，所以支持HTTP也就一定支持TCP
HTTP支持的是www服务，而TCP/IP是协议
HTTP是基于TCP连接基础上的
TCP就是单纯建立连接，不涉及任何我们需要请求的实际数据；HTTP是用来收发数据的，即实际应用上来的（从这种意义上HTTP与Socket可以看作是对等的）

总结：其实HTTP、WebSocket、Socket都是基于TCP连接基础之上的
          HTTP只不过做了封装，不再需要TCP保持连接，一次请求回复之后就断开连接
     WebSocket可以看作HTTP协议的升级，本身还需要HTTP建立TCP连接，一旦建立之后就没有HTTP协议什么事情了，之后都是WebSocket协议
          Socket则延续了TCP保持连接的特性，Socket套接字API的出现是为了上层应用层面用的，另外一点是Socket可以支持不同的传输层协议，TCP只是一种而已

短连接，长连接

通常的短连接操作步骤：连接 -> 数据传输 -> 关闭连接
通常的长连接操作步骤：连接 -> 数据传输 -> 保持连接(心跳) -> 数据传输 -> 保持连接(心跳) -> 数据传输 -> ... -> 关闭连接
所以长连接就要求在没有数据通信时，定时发送数据包(心跳)，以维持连接状态；短连接在没有数据传输时就直接关闭连接即可

长连接：在一个TCP连接上可以连续发送多个数据包，在TCP连接保持期间，如果没有数据包发送，需要双方发检测包(心跳)以维持连接，一般这个需要自己做
短连接：通讯双方有数据交互时，建立一个TCP连接，数据发送完成，就断开TCP连接，比如HTTP

应用场景：
长连接：多用于操作频繁，点对点的通讯，而且连接数不能太多情况
             因为TCP连接数有限，且每个TCP连接需要三步握手需要时间；所以每个操作都要先连接再操作的话速度就很慢(因为要三步握手)，每个操作完不断开，下次处理直接发送数据包，不用新建TCP连接
             长连接因为要被保持，所以对于服务端来说会耗费一定的资源
短连接：多用于Web网站的HTTP服务
             试想，如果一个被成千上万或者上亿的客户访问的Web网站，都使用长连接的话 -> 先不谈TCP连接数的限制，且说服务端维护每个长连接耗费的资源时巨大的
             所以用短连接会省很多资源，当并发量大，但每个用户无需频繁操作情况下，用短连接比较好

摘录：
长连接：在页面里嵌入一个隐蔵iframe，将这个隐蔵iframe的src属性设为对一个长连接的请求，服务器端就能源源不断地往客户端输入数据。
　　优点：消息即时到达，不发无用请求。
　　缺点：服务器维护一个长连接会增加开销。
　　实例：Gmail聊天

(短)轮询，长轮询

轮询：客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。
　　优点：后端程序编写比较容易。
　　缺点：请求中有大半是无用，浪费带宽和服务器资源。（而每一次的 HTTP 请求和应答都带有完整的 HTTP 头信息，这就增加了每次传输的数据量）
　　实例：适于小型应用。

长轮询：客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接（或到了设定的超时时间关闭连接），客户端处理完响应信息后再向服务器发送新的请求。
　　优点：在无消息的情况下不会频繁的请求，节省了网络流量，解决了服务端一直疲于接受请求的窘境
　　缺点：服务器hold连接会消耗资源，需要同时维护多个线程，服务器所能承载的TCP连接数是有上限的，这种轮询很容易把连接数顶满。
　　实例：WebQQ、Hi网页版、Facebook IM。

单工，半双工，全双工，异步单工，异步双工

根据【通信双方的分工】和【信号传输方向】可以将通信分为：单工、半双工、双工
计算机网路中大都采用双工方式，局域网：半双工；城域网和广域网：全双工

单工(Simplex)：通信双方设备中发送器和接收器分工明确，只能再由发送器向接收器的单一固定方向上传送数据。举例：早期读卡器，打印机
半双工(Half Duplex)：通信双方设备既是发送器又是接收器，两台设备可以相互发送接收消息，但是同意时刻只能向一个方向传送数据。举例：步话机
全双工(Full Duplex)：通信双方设备既是发送器又是接收器，两台设备可以同时再两个方向上传送数据。举例：电话

七层协议 - OSI七层协议
OSI：Open System Interconnection - 开放性的通行系统互连模型，定义非常好的协议规范
OSI七层协议从上到下分别是：应 - 表 - 会 - 传 - 网 - 数 - 物
应、表、会、传：定义应用程序的功能  |  网、数、物：面向网络的端到端的数据流
注意：任何两层(有协议的层)之间都应该存在按照各层协议重新封包，解包的操作

认清概念：最终信息是通过物理层去传输的！！！
一、应用层
1. 直接面向用户，为用户提供应用的接口，即提供不同计算机间的文件传送，访问和管理，电子邮件内容处理等
2. 应用层的数据可以称之为：消息
二、表示层
1. 表示层的任务：把 所传送的数据的抽象语法变换为传送语法，即把不同计算机内部的不同表示形式转换成网络通信中标准表示形式
2. 可以对传送的数据进行数据加密或解密、正文压缩或还原等
三、会话层
1. 会话层对传输的报文提供同步管理服务
2. 在两个不同系统的相互通信的应用程序进程之间建立、组织、协调交互，例如确定是双工还是半双工工作
四、传输层
1. 传输层传输的数据单位：报文
2. 传输层是高底层之间衔接的接口层，该层是计算机网络协议分层中最关键的一层，该层以上的各层将不再管理信息传输问题
3. 当报文较长时将它分割成若干分组，然后交给网络层进行传输
五、网络层
1. 网络层传输的数据单位：分组、数据包(packet)
2. 网络层的任务：选择合适的路由和交换节点，完成网络的寻址功能
3. 将数据分组从源(源端系统)送到目的地(目标端系统)
4. 让源的传输层传下来的根据协议转化之后的分组信息能够正确无误按照地址找到目的地，并交付给目标端系统的传输层
六、数据链路层
1. 在网络节点间的线路上传送以帧为单位的数据，传送数据单位：帧(frame)
2. 无差错：通过检测、流量控制、重发等手段
3. 帧必须同时带有 同步、地址、差错控制、流量控制 等控制信息
七、物理层
1. 为数据链路层提供物理连接，物理层串行传送比特流，传送数据单位：比特(bit)
2. 确定链接设备的电气特性和物理特性，确保原始数据可在各种物理媒体上传输

四层协议 - TCP/IP四层协议
TCP/IP：用于计算机通信的一组协议，我们称之为TCP/IP协议族
TCP/IP包括 TCP、IP、UDP、ICMP、RIP、TELNETFTP、SMTP、ARP、TFTP等协议
TCP：传输控制协议
IP：网间网协议
UDP：用户数据报协议
ICMP：互联网控制信息协议
SMTP：简单邮件传输协议
SNMP：简单网络管理协议
FTP：文件传输协议
ARP：地址解析协议

认清概念：最终信息是通过物理层去传输的！！！
信息传播过程简单地描述为：信源→信道→信宿。
其中，“信源”是信息的发布者，即上载者；“信宿”是信息的接收者，即最终用户

TCP/IP根据协议分层模型来讲：
从下到上可以划分为四个层次：应用层、传输层、网间网层、网络接口层

一、应用层
1. 向用户提供一组常用的应用程序，比如电子邮件、文件传输访问、远程登录等
2. 比如 远程登录TELNET使用TELNET协议提供在网络其他主机上注册的几口，TELNET会话提供了基于字符的虚拟终端
3. 比如 文件传输访问FTP使用FTP协议来提供网络内机器间的文件拷贝功能
二、传输层
1. 传输层的作用：提供应用程序间的通信
2. 格式化信息流；提供可靠传输
3. 为实现后者，传输层协议规定接收端必须发回确认，加入分组丢失，必须重新发送
三、网间网层
1. 网间网层的作用：负责相邻计算机之间的通信
2. 功能：处理来自传输层的分组发送请求，收到请求后，将分组装入IP数据报，填充报头，选择去往信宿机的路径，然后将数据报发往适当的网络接口
3. 功能：处理输入数据报，检查合理性，然后寻径；如果数据已经到达信宿机，则去掉报头，将剩下部分交给适当的传输协议；加入数据并没有到达信宿机，则转发该数据报
4. 功能：处理路径、流控、拥塞等问题
四、网络接口层
1. 负责接收IP数据报并通过网络发送之，或者从网络上接收物理帧，抽出IP数据报，交给IP层

七层协议 与 四层协议
OSI层功能TCP/IP协议族应用层文件传输、电子邮件、文件服务、虚拟终端TFTP、FTP、SNMP、SMTP、TELNET、DNS、HTTP表示层数据格式化、代码转换、数据加密无协议会话层解除或建立于别的节点的联系、确定单工/双工/半双工无协议传输层提供端对端的接口TCP、UDP网络层为数据包选择路由IP、ICMP、RIP、OSPF、BGP、IGMP数据链路层传输有地址的帧以及错误检测功能ARP、RARP、MTU、SLIP、CSLIP、PPP物理层以二进制数据形式在物流媒体上传输数据ISO2110、IEEE802、IEEE802.2

几点解释：
1. 数据链路层包括硬件接口和协议ARP、RARP，这两个协议主要用来建立送到物理层上的信息和接收从物理层上传来的信息
2. 网络层协议主要用IP等协议，包含IP协议模块，是所有TCP/IP协议网络的核心，在网络层中，IP模块完成大部分功能
3. 传输层上的主要协议是TCP和UDP。网络层控制着主机之间的数据传递，传输层控制着那些即将进入网络层的数据。TCP和UDP协议正式管理这些数据的两种方式：
    TCP基于连接的协议；UDP面向无连接服务的管理方式的协议

比特、帧、报文、报文段、分组、包、数据包概念
比特 - 物理层  |  帧 - 数据链路层  |  分组、数据包 - 网络层  |  报文 - 传输层

1.报文(message)
报文是网络中交换与传输的数据单元，也是网络传输的单元。报文包含了将要发送的完整的数据信息，其长短不需一致。报文在传输过程中会不断地封装成分组、包、帧来传输，封装的方式就是添加一些控制信息组成的首部，那些就是报文头。
 
2.分组(packet)
分组是在网络中传输的二进制格式的单元，为了提供通信性能和可靠性，每个用户发送的数据会被分成多个更小的部分。在每个部分的前面加上一些必要的控制信息组成的首部，有时也会加上尾部，就构成了一个分组。
 
3.数据包(data packet)
数据包是TCP/IP协议通信传输中的数据单元，也称为“包”。是指自包含的，带有足够寻址信息，可独立地从源主机传输到目的主机，而不需要依赖早期的源主机和目的主机之间交换信息以及传输网络的数据包。
 
4.数据报(datagram)
面向无连接的数据传输，其工作过程类似于报文交换。采用数据报方式传输时，被传输的分组称为数据报。
 
5.帧(frame)
帧是数据链路层的传输单元。它将上层传入的数据添加一个头部和尾部，组成了帧。