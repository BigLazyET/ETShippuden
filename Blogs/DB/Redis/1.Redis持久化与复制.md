Redis持久化
-------------

### 一、持久化选项
持久化方法可同时使用，也可单独使用
* 快照
* AOF（append-only file）

### 二、持久化的作用
* 数据备份
* 复杂计算逻辑后的数据落库，方便重用

### 三、Redis配置

在redis.conf中的ADVANCED CONFIG部分
redis.conf详解：https://www.cnblogs.com/wsxdev/p/11594678.html
https://blog.csdn.net/qq_32403063/article/details/90347194
https://blog.csdn.net/qq_24641227/article/details/93520057

#### 1. 快照持久化选项配置-举例
```
// 快照文件的保存位置
dir ./
// 多久执行一次自动快照操作
// 从最近一次创建快照后算起，当"60s内有1000此写入"这个条件被满足时，Redis会自动触发BGSAVE命令
// **如果用户设置多个save选项，那么任意一个save配置选项条件被满足，那么就会触发BGSAVE命令**
save 60 1000
// 创建快照失败后不继续执行写命令
stop-writes-on-bgsave-error no
// 对快照文件进行压缩
rdbcompression yes
// 命名磁盘上的快照文件为dump.rdb
dbfilename dump.rdb
```

#### 2. AOF持久化选项配置-举例
```
// AOF文件的保存位置
dir ./
// 使用AOF进行持久化
appendonly on
// 写入AOF文件到磁盘的频率
appendfsync everysec
// 
no-appendfsync-on-rewrite no
// 
auto-aof-rewrite-percentage 100
// 
auto-aof-rewrite-min-size 64mb
```

### 三、快照持久化

#### 1. 基本认知
* 创建快照获取存储在内存中的**某个时间点**的数据副本
* 可对快照再次进行备份
* 可将快照复制到其他服务器从而创建具有相同数据的服务器副本(从服务器)
* 快照保留在原地以便服务器重启重新加载
* 结合第二点中的配置：新建快照会被写入dbfilename选项指定的文件里，并存储在dir选项指定的路径之下

**在新的快照文件创建完毕之前，Redis，系统或者硬件三者任意一个崩溃，那么Reids将丢失最近一次创建快照之后写入的所有数据**

#### 2. 创建快照的方法
* 客户端发送**BGSAVE**命令给Redis；对于支持BGSAVE命令的平台来说(Windows现在未知)，Redis调用fork创建子进程，子进程服务将快照写入硬盘，父进程继续处理命令请求
* 客户端发送**SAVE**命令给Redis，Redis服务器接收到SAVE命令创建快照结束之后**不再响应其他任何命令**；所以这种需求并不常见，除非Redis服务器内存接近使用完成了或者等待持久化操作执行完毕后再去继续处理命令请求也没关系
* 用户**设置save配置选项**：save 60 1000；从上一次创建快照算起，"60s内1000次写入条件"被满足，Redis会自动触发BGSAVE命令
* 用户**设置多个save配置选项，任意一个条件被满足就会触发BGSAVE命令**
* Redis服务器接收到**SHUTDOWN**命令或者接收到标准**TERM**信号时，执行**SAVE**命令，此时Redis服务器阻塞所有连接的客户端，不再执行客户端发送的任何命令，在SAVE命令执行完毕后关闭服务器
* 主从服务器：从服务器连接到主服务器，向对方发送**SYNC**命令来开始一次复制操作（**如果主服务器当前没有在执行BGSAVE操作，或者主服务器并没有刚刚执行完BGSAVE操作**），那么主服务器将执行BGSAVE命令

#### 3. 快照持久化适用范围
**快照持久化保存数据时，一旦系统，Redis，硬件发生崩溃，将丢失最近一次生成快照成功之后的所有数据**
* 适用于即使丢失一部分数据也不会造成问题的程序，可以接受这种数据损失
* 取决于我们可以接受多长范围内的数据损失，如果丢失一个小时内的产生的数据是可以接受的，那么使用配置：save 3600 1即可

#### 4. 恢复因为故障而被中断的日志处理操作
一言以蔽之：创建函数，将Redis连接，存储日志文件的路径和一个委托/回调作为参数。
进而处理未处理的日志文件，将日志的处理进度记录到Redis里

#### 5. 快照持久化的不足
* 当Redis存储的数据过于庞大的时候，BGSAVE创建子进程耗费的时间越来越多，生成快照所需要的时间就越长
* 当Redis服务器剩余内存不多，运行在虚拟机中等，BGSAVE也会造成系统长时间停顿。
(既然是子进程负责写入快照，父进程正常处理命令，为啥还会停顿)，这里的停顿更多的是父进程去创建子进程的时候耗费的时间很多

### 四、AOF持久化
* AOF持久化是将被执行的写命令写到AOF文件的末尾
* 恢复的时候，Redis只要从头到尾重新执行一次AOF文件里包含的所有写命令，就可以恢复AOF文件所记录的数据集
* appendonly yes 配置选项打开AOF持久化

#### 1. 文件同步的概念 - ==十分重要==
* 向硬盘写入文件时，file.write()对文件进行写入，写入的内容首先会存储到缓冲区
* 操作系统会在将来某个时候将缓冲区存储的内容写入硬盘
* 只有当数据写入硬盘后，才算真正保存到硬盘里
* 在向硬盘写入文件的过程中，我们可以通过调用file.flush()方法请求操作系统尽快将缓冲区存储的数据写入硬盘，但这只是请求，至于合适执行写入才做还是由操作系统决定
* 我们还可以通过sync命令操作系统将文件同步到硬盘，此时同步操作会一直阻塞直到指定的文件被写入硬盘

#### 2. appendfsync
**appendfsync配置选项控制对AOF文件的同步频率**
* appendfsync always/everysec/no
* always - 每个Redis写命令都要同步写入硬盘，这样会严重降低Redis的速度；但是于此同时系统发生崩溃出现的数据丢失会减到最少
* always - 这种同步策略会对硬盘进行大量写入，所以Redis处理命令速度会受到硬盘性能的限制
* always - 转盘式硬盘(spinning disk)，在这种同步策略下每秒只能处理大约200个写命令；而固态硬盘(solid-state drive，SSD)每秒只能处理几万个写命令
* everysec - 每秒一次的频率对AOF文件进行同步，这种频率同步对Redis的性能造成的影响很小
* everysec - 系统崩溃最多丢失一秒之内的数据；硬盘忙于写操作，Redis会自动放慢自己的速度来适应硬盘的写入速度
* no - 没有同步频率没有显式的限制，由操作系统决定；因此不推荐，因为一旦崩溃无法确定丢失的数据多少；硬盘写入速度不快的话，缓冲区等待被写入硬盘的数据填满后，Redis的写入操作将被阻塞，导致处理请求命令速度变慢

#### 3. 固态硬盘的写放大问题 
appendfsync always配置时，Redis每次只写入一个命令，而不是一次性写入多个命令；
不断写入少量数据的做法会引发严重的写入放大问题！

### 五、重写/压缩AOF文件

#### 1. AOF持久化的缺陷
* AOF文件的体积大小
* AOF文件体积过大可能会用完硬盘所有的可用空间
* AOF文件体积过大，在Redis服务器重启还原数据集的时候，执行AOF文件中的命令来还原，其执行的时间可能会非常长

#### 2. 解决AOF持久化的缺陷
上面说过了，AOF持久化的缺陷就是AOF文件体积的不断增大的问题。
* 发送**BGREWRITEAOF**命令给Redis：此命令会移除AOF文件中冗余命令来重写AOF文件
* BGREWRITEAOF的工作员里和BGSAVE创建快照的原理类似：创建一个子进程，子进程负责对AOF文件进行重写
* BGREWRITEAOF的原理时通过创建子进程对AOF进行重写，那么就可能造成性能问题和内存占用问题（回忆快照持久化BGSAVE的弊端，当Reids数据过大，创建子进程的时间就会很长！）
* AOF文件的体积可能会比快照文件体积大好几倍，进行AOF重写并删除旧AOF文件时，删除一个大体积的旧AOF文件会导致操作系统挂起数秒
* 设置**auto-aof-rewrite-percentage**
* 设置**auto-aof-rewrite-min-size**
* **以上两个选项配置用来限制条件以触发自动执行BGREWRITEAOF**
* auto-aof-rewrite-percentage 100和auto-aof-rewrite-min-size 64mb：当AOF文件体积大于64MB，并且AOF文件的体积比上一次重写之后的体积打了至少一倍(100%)的时候，Redis自动执行BGREWRITEAOF
* 如果AOF重写过于频繁，可以考虑将auto-aof-rewrite-percentage设置为更大一些，表明在AOF文件体积变得更大的时候才进行BGREWRITEAOF


Redis复制
-------------------

### 一、复制
* 让其他服务器(从服务器)拥有一个不断更新的数据副本，使这些服务器可以用于处理客户端发送的读请求(扩展了读性能)

#### 1. Redis复制前提认知

* 正常情况下，从连主(相当于从给主发送了一个SYNC命令)，主会执行BGSAVE操作(如果不是刚刚BGSAVE结束或者正在BGSAVE过程中的话)
* 所以必须配置好快照的配置，比如dir和dbfilename选项

#### 2. 复制基本配置
* slaveof host port配置 - Redis服务器会根据选定的IP地址和端口号连接主服务器
* 向运行中的Redis服务器发送SLAVEOF host port命令
* 发送SLAVEOF no one命令让服务器中止复制操作，不再接受主服务器的数据更新
* 如果采用的是slaveof配置的方式，那么Redis服务器在启动时，首先会载入当前可用的任何快照文件或者AOF文件，然后执行下面第2点的复制过程
* 如果采用的SLAVEOF命令的方式，那么运行中的Redis服务器会立即尝试连接主服务器，在连接成功后，执行下面第2点的复制过程

### 二、Redis复制的启动过程

步骤 | 主服务器操作 | 从服务器操作
---|---|---
1 | 等待SYNC命令 | 连接(或者重连接)主服务器，发送SYNC命令
2 | 开始执行BGSAVE，并**使用缓冲区记录BGSAVE之后执行的所有写命令** | 根据配置选项来决定是继续使用现有的数据(如果有的话)来处理客户端的命令请求，还是向发送请求的客户端返回错误
3 | BGSAVE执行完毕，向从服务器发送快照文件，发送期间继续使用缓冲区记录被执行的写命令 | **丢弃所有旧数据(如果有的话)**，开始载入主服务器发送来的快照文件
4 | 快照发送完毕，向从服务器发送存储在缓冲区的写命令 | 完成快照文件的解释操作，然后开始接受命令请求
5 | 缓冲区存储的些命令发送结束，从现在开始，每执行一个写命令，就向服务器发送相同的写命令 | 执行主服务器发来的所有存储在缓冲区里的写命令；然后接受并执行主服务器传来的每个写命令

#### 1. 对于上述表的一些解释

* Redis在复制期间也会尽可能处理接收到的命令请求
* 如果**主从之间网络带宽不足，或者主服务器没有足够的内存来创建子进程和创建记录写命令的缓冲区**，那么Redis处理命令请求的效率就会被影响
* 所以尽管不是必须的，==注意啊，考点啊！！！==**但为了规避上述情形，实际使用中主服务器只使用50%-65%的内存，留下30%-45%的内存用于执行BGSAVE命令(即创建子进程来创建快照)和创建记录写命令的缓冲区**
* **Redis不支持主主复制**！
* Redis集群不能保证数据的==强一致性==

**Redis集群异步复制的步骤：** ==重要==
* Redis主节点接收到客户端的写命令
* Redis主节点回复客户端写命令之后的状态
* Redis主节点将写命令复制给它的所有从节点(这一步会由于各种原因，导致写命令没有被复制到从节点上去)

#### 2. 多个从连同一个主的情形
* 新的从连接主 且 上述表中第3步尚未执行，那么所有从将会接收到相同的快照文件和相同的缓冲区写命令
* 新的从连接主 且 上述表中第3步正在执行或已经执行结束，那么主与较早的从完成复制操作之后，主再跟新连接的从再从头开始执行一次复制操作

### 三、主从链

创建多个从服务器可能会造成网络不可用，因为复制需要通过互联网进行或者在不同的数据中心之间进行。

而Redis的主和从服务器没有特别上的不同，所以从服务器也可以拥有自己的从服务器，由此形成主从链

#### 1. 主从链的必要性

创建一个由Redis主从节点组成的中间层来分担主服务器的复制工作：
* 需要扩展读性能，读请求的重要性明显高于写请求的重要性
* 读请求数量超出一台Redis服务器可以处理的范围
* 负载增多，主服务器无法快速更新所有从服务器
* 负载增多，因为重新连接和重新同步从服务器导致系统超载

#### 2. 检测硬盘写入

如何验证主服务器是否已经把写数据发送至从服务器：
* 在主服务器写入真正的数据之后，再向主服务器写入一个唯一的虚构值
* 通过检查这个虚构值是否存在于从服务器来判断写数据是否已经到达了从服务器

如何验证数据是否已经被保存到硬盘：
* appendfsync everysec配置保证每隔一秒写数据保存到硬盘
* 但是更节约的方式是检查INFO命令的输出结果中aof_pending_bio_fsync属性值是否为0；如果是0，则表示服务器已经将一致的所有数据都保存到硬盘里了

处理Redis系统故障
---------------

确保数据的一致性：
* 验证持久化文件是否完好无损
* 必要时可以对持久化文件进行修复
* 更换出现故障的Redis服务器

### 一、验证快照文件

#### 1. Redis提供了命令行程序
* redis-check-dump，可以在系统故障发生之后，检查快件文件的状态

#### 2. 快照文件保留多个备份的重要性
* 目前没有办法修复出错的快照文件
* 因为快照文件本身进行了压缩，而在文件中间的错误可能导致快照文件剩余部分无法被读取
* 可以通过计算快照文件的SHA1散列值和SHA256散列值对内容进行验证
* Redis2.6版本开始，快照文件中包含自身的CRC64校验和，通过CRC64校验和验证快照文件是否完整，对于发现典型的网络传输错误和硬盘损坏非常有帮助
* ==SHA1和SHA256和CRC64，抽空得看==

### 二、验证AOF文件

#### 1. Redis提供了命令行程序
* redis-check-aof，可以在系统故障发生之后，检查AOF文件的状态

#### 2. 修复AOF文件
* 运行redis-check-aof时指定--fix参数，程序就会对AOF文件进行修复
* 修复AOF文件的方法非常简单：扫描给定的AOF文件，寻找不正确的或者不完整的命令
* 当发现第一个出错的命令时，删除出错的命令及其之后的所有命令，只保留出错的命令之前的正确命令
* 在大多数情况下，被删除的时AOF文件末尾的不完整的写命令

### 三、更换故障主服务器

#### 1. 针对一主一从的情况

##### A主B从，备用主C：
* A因故障断开了网络连接
* 向B发送SAVE命令，创建快照文件，并不再处理之后的命令请求
* 将B创建的快照文件发送给C
* 在C上启动Redis
* 在B上运行SLAVEOF ip port的命令让B成为C的从服务器

##### A主B从，B升主
可以借助Redis Sentinel哨兵，监视指定的Redis主服务器以及下属从服务器，并在主服务器下线时自动进行故障转移(failover)


























 
