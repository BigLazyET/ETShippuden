Redis内存优化
------

### 一、前言
#### 1. 降低Redis内存占用的好处
* 有助于减少创建快照和加载快照所需的时间
* 提升载入AOF文件和重洗AOF文件时的效率
* 缩短【从服务器】进行同步所需要的时间

#### 2. 降低Redis内存占用的几种方式
* 短结构：更高效地表示数据
* 分片技术：将一些体积较大地结构分割为多个体积较小地结构
* 打包存储二进制位和字节：将固定长度地数据打包存储到字符串键里

#### 3. 下述配置位置
* 在redis.conf中的ADVANCED CONFIG部分
* redis.conf详解：https://www.cnblogs.com/wsxdev/p/11594678.html
* https://blog.csdn.net/qq_32403063/article/details/90347194
* https://blog.csdn.net/qq_24641227/article/details/93520057

### 二、短结构
**Redis为列表、集合、散列和有序集合提供了一组配置选项，这些选项让Redis以更节约空间的方式存储长度较短的结构(短结构)**

#### ziplist数据结构详解：
* https://blog.csdn.net/yellowriver007/article/details/79021049

#### 1. 常规认识
当列表、散列和有序集合的长度较短或者体积较小的时候，Redis可以选择使用一种名为**压缩列表(ziplist)的紧凑存储方式**来存储这些结构

###### 压缩列表：
* 是列表、散列和有序集合这3种不同类型的对象的一种非结构化表示
* 会以序列化的方式存储数据
* 序列化数据每次被读取的时候都要进行解码，每次被写入都要进行局部的重新编码，并且可能需要对内存里面的数据进行移动

###### Redis通常情况下数据结构的底层数据结构：

列表(list) | 散列(hash) | 有序集合(sorted set)
---|---|---
双链表(doubly linked list) | 散列表 | 散列表+跳跃表(skiplist)

#### 2. 详细解释

为什么压缩列表比其他数据结构更为节约内存？我们以列表结构来举例观察。

**典型的双向链表：**
* 链表包含的每个值都会由一个节点表示
* 每个节点带有指向链表种前一个节点和后一个节点的指针以及带有包含指向字符串值的指针
* 而每个节点包含的字符串值都会分为3个部分进行存储：第一部分存储的是字符串的长度；第二部分存储的是字符串值种剩余可用的字节数量，而最后一部分存储的是以空字符结尾的字符串本身

双向链表存储3个3字符长的字符长 => 每个都需要空间来存储3个指针、2个整数(一个是字符长的长度，另一个是字符串的剩余可用空间)、字符串本身以及一个额外的字节(空字符)

在32位平台上，每存储一个这样的3字节长的字符串，就需要**额外**付出21字节的额外开销；而这时保守估计，实际额外开销肯定比这个大

**压缩列表：**
* 由节点组成的序列
* 每个节点都有两个长度值和一个字符串组成
* 第一个长度值记录的时前一个节点的长度，此将被用于对压缩列表进行从后向前的遍历
* 第二个长度值记录了当前节点的长度
* 而位于节点最后的则是被存储的字符串值
* 虽然压缩列表节点的长度值在实际中有其他的含义，此处不予深究

对于例子中"one"、"two"、"ten"这个3个3字节长的字符串来说，每个长度都可以用1字节来存储 => 所以压缩列表来存储这三个字符串时，每个节点只会由2字节的额外开销

**通过避免存储额外的指针和元数据，使用压缩列表可以讲存储示例种的3个字符串所需的额外开销从原来的21字节降低至2字节**

#### 3. 使用压缩列表编码
为了确保压缩列表只会在有需要降低内存占用的情况下使用，redis引入了配置选项，从而决定了列表、散列、有序集合使用压缩列表表示的情形：

* list-max-ziplist-entries 512
* list-max-ziplist-value 64
* hash-max-ziplist-entries 512
* hash-max-ziplist-value 64
* zset-max-ziplist-entries 128
* zset-max-ziplist-value 64

entries：列表、散列和有序集合在被编码为压缩列表的情况下，允许包含的最大元素数量
value：压缩列表每个节点的最大体积是多少字节
当以上选项任意一个被突破的时候，Redis就会将相应的列表、散列或有序集合从压缩列表编码转换为其他结构，而内存占用也会因此增加

可以用DEBUG OBJECT命令可以很方便地了解一个对象是否被存储成了压缩列表，从而进行输出测试。
当给列表加入越来越多的项的时候，列表底层的数据结构会发生变化从：
encoding：ziplist -> encoding：linkedlist

#### 4. 集合的紧凑表示
* 上述的压缩列表适用于列表、散列和有序集合
* 而针对集合，也有自己的紧凑表示，称为整数集合：intset

当然集合的紧凑表示有相应的前提：
* 集合的所有成员都是整数，且都可以被解释成十进制的整数
* 所有整数处于平台的有符号整数范围之内
* 集合成员数量足够少（具体限制大小也会有上面的那样的配置来限制）

当满足以上条件后，Redis就会以有序整数数组的方式存储集合，这种存储方式：整数集合(intset)

同样Redis提供了定义整数集合最大元素数量的配置选项：
* set-max-intset-entries 512
* 上述配置的含义：集合在使用整数集合编码时能够包含的最大元素数量
* 当整数集合元素数量超过配置选项设定的限制时，集合会从整数集合转换为散列表（注意这里是散列表数据结构，不是Redis的散列！！！！）

#### 5. 讨论长压缩列表和大整数集合的性能问题
当一个结构突破压缩列表或者整数集合的配置限制时，Redis会自动把它转换为更为典型的底层结构类型
随着紧凑结构的体积变得越来越大，操作这些结构的速度也变得越来越慢

#### 6. 也可以通过减少键长度，来有效降低内存占用
username:joe -> user:joe -> 如果user不言而喻，则直接joe即可

#### 7. 延申思考
==紧凑类型的结构，比如压缩列表ziplist，对数据的存取时是如何进行的？==
* https://blog.csdn.net/yellowriver007/article/details/79021049

### 三、分片结构

**分片：**
* 扩展存储空间并提高所能处理的负载量
* 本质上是基于某些简单的规则蒋数据划分为更小的部分，然后根据数据所属的部分来决定将数据发送到哪个位置上面

**分片结构：**
* 分片的概念可以应用到 散列、集合和有序集合上
* 程序不再是将X存储到键Y里面，而是将值X存储到键Y:<shardid>里面
* 对列表分片比较困难，可通过Lua脚本辅助实现，从而构建分片式的列表表现，实现以阻塞和非阻塞的方式从列表两端进行推入和弹出操作
* 对有序集合进行分片，但其中有些命令比如ZRANGE，需要对所有分片进行操作后才能得出最终的结果，所以无法像普通有序集合操作那么快，此类就作用不大

#### 1. 分片式散列

基本思想：
* 对散列进行分片，可以把散列存储的键作为其中一个数据源，使用散列函数为键计算出一个数字散列值
* 根据键总数量及没跟分片需要存储的键数计算分片数量
* 最后根据分片数量 跟 散列函数计算出来的数字散列值 来决定键应该存储到哪个分片

注意点：
* 预计的元素总量(total_elements)和请求的分片数量(shard_size)需要合理控制并不要随意变化
* 当以上任何一个发生变化都会导致分片数量发生变化，现有已经存的数据就需要迁移新分片
* 综上，不应该轻易去改变元素总量和分片数量这两个评估预计的参数；如果万不得已需要改动，就需要使用**重新分片程序将数据从旧分片迁移到新分片**

#### 2. 分片式集合

基本思想跟分片式散列一样：关键就是找到一个好的切入点去划分分片

分片键的生成：尽量利用整数直接去构造，但整数必须是密集出现的

#### 3. 分片式列表
重要，留遗

#### 4. 思考：为什么分片式散列/集合就减少内存了？

相同的数据存进去，只不过用了分片的思想去存储，为什么就达到了减少占用内存的作用了：
* 你需要发散思维，前后贯通的去思考
* 思考第一点减少内存占用的方法：短结构
* 当你把所有的数据单独放到一个散列或者集合中，那么Redis底层的编码方式就是传统形式的编码
* 而如果你把数据进行分片，每片的数据足够小，满足ziplist/intset的配置，那么Redis底层的编码方式就会是压缩列表ziplist或者intset整数集合这样的紧凑类型的存储结构；而这两种结构正好是短结构，从而做到了有效减少内存占用的情况


### 三、打包存储二进制位和字节

分片字符串，同时兼容可以进行聚合计算，暂时不表，感觉用的场景不多


