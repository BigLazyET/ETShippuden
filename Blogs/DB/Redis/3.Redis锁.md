Redis锁
-----------

### 文章推荐

* [细说Redis分布式锁](https://juejin.im/post/5e61a454e51d4526f071e1df)

**提前复习：**

在[4、Redis事务]中提及到Redis采取WATCH对键加锁的行为，实际上是一种乐观锁；

与传统关系型数据库的悲观锁不一样

### 一、分布式锁

#### 1. 特征
* 获取锁，执行操作，释放锁
* 不是给同一个进程的多个线程使用；也不是给同一台机器上的多个进程使用
* 由不同机器上的不同Redis客户端进行获取和释放的

#### 2. 锁的选型

为什么不选择操作系统级别的锁、编程语言级别的锁或者其他锁，而是使用Redis构建锁：
* 为了对Redis的数据进行排他性访问，Redis客户端需要访问一个锁
* 而这个锁必须要让其他Redis客户端看得见
* 所以这个锁的范围限定在了Redis本身，所以就需要把锁构建在Redis里面


#### 3. 为什么使用锁代替WATCH命令
* 使用WATCH命令来监视被频繁访问的键会引起性能问题
* WATCH、MULTI和EXEC组成的事务不具有可扩展性
* 程序在尝试完成一个事务的时候，会因为事务执行失败而反复进行重试

#### 4. 构建Redis锁的潜在的问题和挑战
**注意：大部分问题场景在文档开头处的链接里有描述**
* 客户端取得锁崩溃后，锁一直时被获取状态，未被释放
* 锁加了超时时间，但是由于持有锁的进程操作了太长时间导致锁被释放了，而进程本身并不知道
* 接上一个场景：进程执行结束之后，因为不知道锁已经超时释放了，而继续去释放锁，这时候就有可能释放被别的进程获取的锁，造成不可预想的问题
* 一个持有锁打算执行长时间操作的进程崩溃，但是未到这个进程持有锁的超时时间，所以其他想要获取锁的进程只能拜拜浪费时间等待锁自己超时释放；因为其他进程没办法检测持有锁的进程已经崩溃了
* 一个进程持有的锁超时过期后，其他多个进程同时尝试去获取锁，有几率会出现同时获得锁的情形

### 二、简易锁(版本1)

买家/卖家/市场：这么简单的一个买卖逻辑用代码实现，如果操作不限制为原子性，那么会出现各种各样奇怪的情形：
* 钱打给了卖家，但是市场里的货没了
* 货被上架了多次
* 等等其他情形

#### 1. 对市场进行进行加锁
**目标：构建基本的加锁功能**

锁住市场/检查商品价格/确保买家有足够的钱/对钱和商品进行转移：
* 市场：有序集合(成员：货品.卖家ID，分值：价格)
* 买家：散列(正常属性KV)
* 卖家：散列(正常属性KV)

Redis的SETNX命令天生具备实现所得功能：
* 只会在键不存在的情况下为键设置值
* 设置的值可以是一个随机生成128位的UUID，利用这个值防止锁被其他进程取得
* 此值也可以用于在释放锁时，对键值进行前后对比验证，从而确定自己获取的锁是否一直没被修改过

### 三、细粒度锁(版本1.5)
对简易锁选定的锁对象进行更行细粒度的划分

我们只锁住市场里买家关注的那件商品即可

### 四、带有超时限制特征的锁(版本2.0)

#### 1. Redis老版本

创建锁以及给锁加超时时间是分开做的：
* SETNX
* EXPIRE

而当在执行SETNX和EXPIRE命令之间程序崩溃，则加超时时间的操作失败，锁一直被占用着

**针对老版本的优化：**

* 客户端在获取锁失败后，检查锁的超时时间；如果发现没有，就为没有设置超时间的锁设置超时时间
* 即使多个客户端同时发现锁没带超时时间，且都去设置超时时间，因为多个客户端同一时间设置的超时时间基本一致，所以不会出现太大的变化

#### 2. Redis新版本(Redis 2.6.12开始)

创建锁以及给锁加超时时间的动作可以在一个命令中完成，从而保证了原子性：
* SET

计数信号量(一种特殊的锁)
------------------


* 计数信号量锁并没有上述的锁常见，但是它有自己独特的适用范围
* 计数信号量锁同样也需要被获取和释放

#### 1. 与之前锁的区别
* 计数信号量锁可以让用户限制一项资源最多能够同时被多少个进程访问
* 所以我们可以这么看待：**可以把之前创建的锁看作是只能被一个进程访问的信号量**
* ==客户端获取之前创建的锁失败的时候，客户端通常会选择进行等待==
* ==客户端获取计数信号量失败的时候，会立即返回失败的结果==
* ==应用场景：限制同时调用某个资源的API数量；限制针对数据库并发请求等等==

### 一、基本的计数信号量(版本1.0)

构想情景：购买数字版switch游戏，我们希望可以在switch eshop之外就可以在switch游戏商店购买
限制：限制每个账号最多只能有5个进程访问switch游戏商店

#### 1. 同样会遇到构建之前的锁遇到的问题
* 锁超时的问题
* 未释放锁就崩溃
* 锁释放之后竞争的问题

#### 2. 实现超时限制特征的计数信号量的方法
* 使用EXPIRE命令
* ==有序集合(可以将信号量的多个持有者信息存储到同一个结构里)==

#### 3. 实现步骤
* 清理有序集合中所有时间戳大于超时数值的标识符
* 为每个尝试获取信号量的进程生成一个唯一标识符，当作有序集合的成员
* 记录每个进程尝试获取信号量的Unix时间戳，当作有序集合的分值
* 把标识符/时间戳添加到有序集合里之后，进程会检查自己的标识符在有序集合中的排名
* 如果排名低于可获取信号量的进程总数(排名从0开始)，那么就表示进程成功取得了信号量
* 反之则未获取到，并把自己之前添加的标识符移除
* 释放计数信号量：从有序集合里移除指定的标识符即可

#### 4. 存在的问题
* 获取计数信号量时，假定的时每个进程访问到系统时间都是相同的；但这个在多主机环境下并不成立
* 假设系统A和B，A的系统时间比B的系统时间快10毫秒；当A取得计数信号量的时候，B只要在10毫秒内尝试获取信号量，就可以在A毫不知情的情况下，偷走A的计数信号量
* 由于系统时钟的席位不同而导致锁获取结果变化时，这个锁或者信号量是不公平的；
* 不公平的锁和信号量可能会导致客户端永远也无法取得它原本应该得到的锁或信号量；

### 二、公平信号量(版本2.0)

系统时钟较慢的系统上运行的客户端，能够偷走系统时钟较快系统上运行的客户端已经取得的信号量，导致信号量不公平

#### 1. 基本思路

==为了减少系统时间不一致带来的问题，需要给原先的基础计数信号量1.0版本实现**添加**一个计数器以及一个信号量持有者有序集合，总计：==
* 一个字符串计数器A
* 一个信号量持有者有序集合B
* 一个信号量信息有序集合C，又叫超时有序集合(基本计数信号量中的有序集合)

#### 2. 基本步骤
* 从C中移除过期元素的方式移除超时的信号量
* 对B和C执行交集运算(B的权重：1，C的权重：0)，将计算结果保存到B中，覆盖B中原有的数据
* 程序对计数器执行自增操作
* 将计数器生成的值添加到B里；与此同时，将当前系统时间添加到C里
* 程序检查当前客户端添加的标识符在B中排名是否足够低，==如果是，则表示客户端取得了信号量==
* 如果不是，客户端则未取得信号量，那么程序将从B和C中移除与该客户端相关的元素
* 公平信号量和基础信号量的释放基本一致，唯一的区别在于：公平信号量的释放需要同时从B和C中删除当前客户端的标识符

**C在其中担任的角色：判定客户端超时，在步骤一进行对超时客户端进行移除**

### 三、刷新信号量

某些情形下，需要对客户端获取的信号量及时刷新，延迟其过期时间，防止其过期

鉴于B和C有序集合的分开存储，以及分开明确，所以我们其实可以只针对C进行refresh即可：
* 对C进行ZAdd操作，如果成功，即对此客户端持有的信号量进行了刷新
* 如果失败，则表示此客户端的信号量已经过期了，直接返回结果给客户端失败的信息

### 四、消除竞争条件

由于执行信号量获取操作的客户端和服务器进行多次通信，所以纵然使用公平信号量也很难完全避免竞争条件

为了消除信号量实现中所有可能出现的竞争条件，可以采用带有超时特性的分布式锁(第四大点中)来帮助构建一个正确的计数信号量：
* 在客户端获取信号量的所有需要的操作之前，先尝试获取一个带有短暂超时功能的分布式锁
* 如果程序成功获取了锁，那么就继续执行正常的获取信号量的操作
* 如果程序未获取到锁，那么信号量获取操作直接宣告失败

### 五、计数信号量的选型
#### 1. 简单分类
* 基本计数信号量A(存在不公平性)
* 公平计数信号量B
* 消除竞争条件的公平计数信号量C

#### 2. 需求选型

* 如果你对于使用系统时钟没有意见，也不需要对信号量进行刷新，并且能够接受信号量
的数量偶尔超过限制，那么可以使用我们给出的第一个信号量实现
* 如果你只信任差距在一两秒之间的系统时钟，但仍然能够接受信号量的数量偶尔超过限
制，那么可以使用第二个信号量实现
* 如果你希望信号量一直都具有正确的行为，那么可以使用带锁的信号量实现来保证正确性












